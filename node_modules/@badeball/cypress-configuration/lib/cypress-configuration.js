"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveProjectPath = exports.resolveConfigurationFile = exports.resolveEnvironment = exports.resolveConfiguration = exports.toCamelCase = exports.capitalize = exports.toSnakeCase = exports.findArgumentValue = exports.combine = exports.traverseArgvMatching = exports.findLastIndex = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const debug_1 = __importDefault(require("./debug"));
const assertions_1 = require("./assertions");
const type_guards_1 = require("./type-guards");
const path_helpers_1 = require("./path-helpers");
function isStringEntry(entry) {
    return typeof entry[0] === "string" && typeof entry[1] === "string";
}
function validateConfigurationEntry(key, value) {
    switch (key) {
        case "projectRoot":
            if (!(0, type_guards_1.isString)(value)) {
                throw new Error(`Expected a string (projectRoot), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        case "integrationFolder":
            if (!(0, type_guards_1.isString)(value)) {
                throw new Error(`Expected a string (integrationFolder), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        case "fixturesFolder":
            if (!(0, type_guards_1.isStringOrFalse)(value)) {
                throw new Error(`Expected a string or false (fixturesFolder), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        case "supportFile":
            if (!(0, type_guards_1.isStringOrFalse)(value)) {
                throw new Error(`Expected a string or false (supportFile), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        case "testFiles":
            if (!(0, type_guards_1.isStringOrStringArray)(value)) {
                throw new Error(`Expected a string or array of strings (testFiles), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        case "ignoreTestFiles":
            if (!(0, type_guards_1.isStringOrStringArray)(value)) {
                throw new Error(`Expected a string or array of strings (ignoreTestFiles), but got ${util_1.default.inspect(value)}`);
            }
            return { [key]: value };
        default:
            return {};
    }
}
function parseJsonFile(filepath) {
    const content = fs_1.default.readFileSync(filepath).toString("utf8");
    try {
        return JSON.parse(content);
    }
    catch (_a) {
        throw new Error(`Malformed ${filepath}, expected JSON`);
    }
}
function findLastIndex(collection, predicate, beforeIndex = collection.length) {
    for (let i = beforeIndex - 1; i >= 0; --i) {
        if (predicate(collection[i])) {
            return i;
        }
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
function* traverseArgvMatching(argv, name, allowEqual) {
    let beforeIndex = argv.length, matchingIndex;
    while ((matchingIndex = findLastIndex(argv, (arg) => arg.startsWith(name), beforeIndex)) !== -1) {
        if (argv[matchingIndex] === name) {
            if (argv.length - 1 === matchingIndex) {
                (0, debug_1.default)(`'${name}' argument missing`);
            }
            else {
                yield argv[matchingIndex + 1];
            }
        }
        else if (allowEqual && argv[matchingIndex][name.length] === "=") {
            yield argv[matchingIndex].slice(name.length + 1);
        }
        beforeIndex = matchingIndex;
    }
}
exports.traverseArgvMatching = traverseArgvMatching;
function* combine(...generators) {
    for (const generator of generators) {
        yield* generator;
    }
}
exports.combine = combine;
function findArgumentValue(argv, name, allowEqual) {
    for (const value of traverseArgvMatching(argv, name, allowEqual)) {
        return value;
    }
}
exports.findArgumentValue = findArgumentValue;
function toSnakeCase(value) {
    return value.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
exports.toSnakeCase = toSnakeCase;
function capitalize(word) {
    return word.toLowerCase().replace(/\b\w/g, (l) => l.toUpperCase());
}
exports.capitalize = capitalize;
function toCamelCase(value) {
    return value
        .split("_")
        .map((word, index) => index === 0 ? word.toLocaleLowerCase() : capitalize(word))
        .join("");
}
exports.toCamelCase = toCamelCase;
function resolveConfiguration(options) {
    (0, debug_1.default)(`attempting to resolve Cypress configuration using ${util_1.default.inspect(options)}`);
    const { argv, env } = options;
    const projectPath = resolveProjectPath(options);
    const cliOrigin = Object.assign({}, ...Array.from(combine(traverseArgvMatching(argv, "--config", true), traverseArgvMatching(argv, "-c", false)))
        .reverse()
        .flatMap((argument) => {
        const keypairExpr = /(?:^|,)([^=]+)=([^,$]+)/g;
        const entries = [];
        let match;
        while ((match = keypairExpr.exec(argument)) !== null) {
            entries.push(validateConfigurationEntry(match[1], match[2]));
        }
        return entries;
    }));
    const envPrefixExpr = /^cypress_(.+)/i;
    const envOrigin = Object.assign({}, ...Object.entries(env)
        .filter((entry) => {
        return envPrefixExpr.test(entry[0]);
    })
        .filter(isStringEntry)
        .map((entry) => {
        const match = entry[0].match(envPrefixExpr);
        (0, assertions_1.assert)(match, "cypress-cucumber-preprocessor: expected match after test, this is likely a bug.");
        return [(0, assertions_1.assertAndReturn)(match[1]), entry[1]];
    })
        .map((entry) => {
        return validateConfigurationEntry(entry[0].includes("_") ? toCamelCase(entry[0]) : entry[0], entry[1]);
    }));
    let configOrigin = {};
    const cypressConfigPath = (0, path_helpers_1.ensureIsAbsolute)(projectPath, resolveConfigurationFile(options));
    if (fs_1.default.existsSync(cypressConfigPath)) {
        const cypressConfig = parseJsonFile(cypressConfigPath);
        if (typeof cypressConfig !== "object" || cypressConfig == null) {
            throw new Error(`Malformed ${cypressConfigPath}, expected an object`);
        }
        configOrigin = Object.assign({}, ...Object.entries(cypressConfig).map((entry) => validateConfigurationEntry(...entry)));
    }
    const configuration = Object.assign({
        projectRoot: resolveProjectPath(options),
        integrationFolder: "cypress/integration",
        fixturesFolder: "cypress/fixtures",
        supportFile: "cypress/support/index.js",
        testFiles: "**/*.*",
        ignoreTestFiles: "*.hot-update.js",
    }, configOrigin, envOrigin, cliOrigin);
    (0, debug_1.default)(`resolved configuration of ${util_1.default.inspect(configuration)}`);
    return configuration;
}
exports.resolveConfiguration = resolveConfiguration;
function resolveEnvironment(options) {
    (0, debug_1.default)(`attempting to resolve Cypress environment using ${util_1.default.inspect(options)}`);
    const { argv, env } = options;
    const projectPath = resolveProjectPath(options);
    const envEntries = Array.from(combine(traverseArgvMatching(argv, "--env", true), traverseArgvMatching(argv, "-e", false)));
    if (envEntries.length > 1) {
        console.warn("You have specified -e / --env multiple times. This is likely a mistake, as only the last one will take affect. Multiple values should instead be comma-separated.");
    }
    const cliOrigin = Object.fromEntries(envEntries.slice(0, 1).flatMap((argument) => {
        const keypairExpr = /(?:^|,)([^=]+)=([^,$]+)/g;
        const entries = [];
        let match;
        while ((match = keypairExpr.exec(argument)) !== null) {
            entries.push([match[1], match[2]]);
        }
        return entries;
    }));
    const envPrefixExpr = /^cypress_(.+)/i;
    const envOrigin = Object.fromEntries(Object.entries(env)
        .filter((entry) => {
        return envPrefixExpr.test(entry[0]);
    })
        .filter(isStringEntry)
        .map((entry) => {
        const match = entry[0].match(envPrefixExpr);
        (0, assertions_1.assert)(match, "cypress-cucumber-preprocessor: expected match after test");
        return [(0, assertions_1.assertAndReturn)(match[1]), entry[1]];
    }));
    const cypressConfigPath = (0, path_helpers_1.ensureIsAbsolute)(projectPath, resolveConfigurationFile(options));
    let configOrigin = {};
    if (fs_1.default.existsSync(cypressConfigPath)) {
        const content = fs_1.default.readFileSync(cypressConfigPath).toString("utf8");
        const cypressConfig = JSON.parse(content);
        if (cypressConfig.env) {
            configOrigin = cypressConfig.env;
        }
    }
    const cypressEnvironmentFilePath = path_1.default.join(projectPath, "cypress.env.json");
    let cypressEnvOrigin = {};
    if (fs_1.default.existsSync(cypressEnvironmentFilePath)) {
        const content = fs_1.default
            .readFileSync(cypressEnvironmentFilePath)
            .toString("utf8");
        cypressEnvOrigin = JSON.parse(content);
    }
    const environment = Object.assign({}, cypressEnvOrigin, configOrigin, envOrigin, cliOrigin);
    (0, debug_1.default)(`resolved environment of ${util_1.default.inspect(environment)}`);
    return environment;
}
exports.resolveEnvironment = resolveEnvironment;
function resolveConfigurationFile(options) {
    const { argv } = options;
    return (findArgumentValue(argv, "--config-file", true) ||
        findArgumentValue(argv, "-C", false) ||
        "cypress.json");
}
exports.resolveConfigurationFile = resolveConfigurationFile;
function resolveProjectPath(options) {
    const { argv, cwd } = options;
    const customProjectPath = findArgumentValue(argv, "--project", true) ||
        findArgumentValue(argv, "-P", false);
    if (customProjectPath) {
        return (0, path_helpers_1.ensureIsAbsolute)(cwd, customProjectPath);
    }
    else {
        return cwd;
    }
}
exports.resolveProjectPath = resolveProjectPath;
