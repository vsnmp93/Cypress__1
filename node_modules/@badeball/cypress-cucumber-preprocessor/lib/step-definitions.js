"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStepDefinitionPatterns = exports.pathParts = exports.getStepDefinitionPaths = void 0;
const path_1 = __importDefault(require("path"));
const glob_1 = __importDefault(require("glob"));
const util_1 = __importDefault(require("util"));
const assert_1 = __importDefault(require("assert"));
const is_path_inside_1 = __importDefault(require("is-path-inside"));
const debug_1 = __importDefault(require("./debug"));
async function getStepDefinitionPaths(configuration, filepath) {
    const files = (await Promise.all(getStepDefinitionPatterns(configuration, filepath).map((pattern) => util_1.default.promisify(glob_1.default)(pattern, { nodir: true })))).reduce((acum, el) => acum.concat(el), []);
    if (files.length === 0) {
        (0, debug_1.default)("found no step definitions");
    }
    else {
        (0, debug_1.default)(`found step definitions ${util_1.default.inspect(files)}`);
    }
    return files;
}
exports.getStepDefinitionPaths = getStepDefinitionPaths;
function trimFeatureExtension(filepath) {
    return filepath.replace(/\.feature$/, "");
}
function pathParts(relativePath) {
    (0, assert_1.default)(!path_1.default.isAbsolute(relativePath), `Expected a relative path but got ${relativePath}`);
    const parts = [];
    do {
        parts.push(relativePath);
    } while ((relativePath = path_1.default.normalize(path_1.default.join(relativePath, ".."))) !== ".");
    return parts;
}
exports.pathParts = pathParts;
function getStepDefinitionPatterns(configuration, filepath) {
    const fullIntegrationFolder = path_1.default.isAbsolute(configuration.cypress.integrationFolder)
        ? configuration.cypress.integrationFolder
        : path_1.default.join(configuration.cypress.projectRoot, configuration.cypress.integrationFolder);
    if (!(0, is_path_inside_1.default)(filepath, fullIntegrationFolder)) {
        throw new Error(`${filepath} is not inside ${fullIntegrationFolder}`);
    }
    if (!(0, is_path_inside_1.default)(filepath, configuration.cypress.projectRoot)) {
        throw new Error(`${filepath} is not inside ${configuration.cypress.projectRoot}`);
    }
    (0, debug_1.default)(`looking for step definitions using ${util_1.default.inspect(configuration.preprocessor.stepDefinitions)}`);
    const filepathReplacement = trimFeatureExtension(path_1.default.relative(fullIntegrationFolder, filepath));
    (0, debug_1.default)(`replacing [filepath] with ${util_1.default.inspect(filepathReplacement)}`);
    const parts = pathParts(filepathReplacement);
    (0, debug_1.default)(`replacing [filepart] with ${util_1.default.inspect(parts)}`);
    return (typeof configuration.preprocessor.stepDefinitions === "string"
        ? [configuration.preprocessor.stepDefinitions]
        : configuration.preprocessor.stepDefinitions)
        .flatMap((pattern) => {
        if (pattern.includes("[filepath]") && pattern.includes("[filepart]")) {
            throw new Error(`Pattern cannot contain both [filepath] and [filepart], but got ${util_1.default.inspect(pattern)}`);
        }
        else if (pattern.includes("[filepath]")) {
            return pattern.replace("[filepath]", filepathReplacement);
        }
        else if (pattern.includes("[filepart]")) {
            return [
                ...parts.map((part) => pattern.replace("[filepart]", part)),
                path_1.default.normalize(pattern.replace("[filepart]", ".")),
            ];
        }
        else {
            return pattern;
        }
    })
        .map((pattern) => path_1.default.join(configuration.cypress.projectRoot, pattern));
}
exports.getStepDefinitionPatterns = getStepDefinitionPatterns;
